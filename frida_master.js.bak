/* 
 * Frida 全功能 Hook 框架
 * 功能：全面监控应用行为，绕过检测，提取加密信息
 * 包含：加密/解密监控，网络监控，反调试绕过，敏感API监控，自动提取密钥等
 */

// 全局配置
var config = {
    logLevel: 'info',           // 日志级别: debug, info, warn, error
    fileLogging: true,          // 是否保存日志到文件
    logFilePath: '/sdcard/frida_log.txt',
    autoExtractKeys: true,      // 自动提取加密密钥
    bypassAllDetection: true,   // 绕过所有检测机制
    colorOutput: true,          // 控制台彩色输出
    stackTrace: false           // 打印调用栈
};

// 日志系统
var logger = {
    debug: function(tag, message) {
        if(config.logLevel === 'debug') {
            this._log('DEBUG', tag, message);
        }
    },
    info: function(tag, message) {
        if(['debug', 'info'].indexOf(config.logLevel) !== -1) {
            this._log('INFO', tag, message);
        }
    },
    warn: function(tag, message) {
        if(['debug', 'info', 'warn'].indexOf(config.logLevel) !== -1) {
            this._log('WARN', tag, message);
        }
    },
    error: function(tag, message) {
        this._log('ERROR', tag, message);
    },
    _formatOutput: function(level, tag, message) {
        var time = new Date().toTimeString().split(' ')[0];
        var levelColor = '';
        
        if (config.colorOutput) {
            // 控制台颜色
            var colors = {
                reset: '\x1b[0m',
                red: '\x1b[31m',
                green: '\x1b[32m',
                yellow: '\x1b[33m',
                blue: '\x1b[34m',
                magenta: '\x1b[35m'
            };
            
            switch(level) {
                case 'DEBUG': levelColor = colors.green; break;
                case 'INFO': levelColor = colors.blue; break;
                case 'WARN': levelColor = colors.yellow; break;
                case 'ERROR': levelColor = colors.red; break;
                default: levelColor = colors.reset;
            }
            
            return colors.magenta + '[' + time + ']' + levelColor + '[' + level + '] ' + 
                   colors.reset + '(' + tag + ') ' + message;
        } else {
            return '[' + time + '][' + level + '] (' + tag + ') ' + message;
        }
    },
    _log: function(level, tag, message) {
        var output = this._formatOutput(level, tag, message);
        console.log(output);
        
        // 保存日志到文件
        if (config.fileLogging) {
            this._logToFile(output);
        }
    },
    _logToFile: function(message) {
        try {
            var file = new File(config.logFilePath, 'a');
            file.write(message + '\n');
            file.flush();
            file.close();
        } catch(e) {
            console.log('Error writing to log file: ' + e);
        }
    }
};

// 工具函数
var utils = {
    hexdump: function(arrayBuffer) {
        var bytes = new Uint8Array(arrayBuffer);
        var res = "";
        for (var i = 0; i < bytes.length; i++) {
            res += ('0' + (bytes[i] & 0xFF).toString(16)).slice(-2) + ' ';
            if ((i + 1) % 16 === 0) res += '\n';
        }
        return res;
    },
    
    bytesToString: function(bytes) {
        var result = '';
        for (var i = 0; i < bytes.length; i++) {
            result += String.fromCharCode(bytes[i]);
        }
        return result;
    },
    
    stringToBytes: function(str) {
        var bytes = [];
        for (var i = 0; i < str.length; i++) {
            bytes.push(str.charCodeAt(i));
        }
        return bytes;
    },
    
    getStackTrace: function() {
        if (!config.stackTrace) return "";
        
        try {
            var Exception = Java.use("java.lang.Exception");
            var exception = Exception.$new();
            var stackTrace = exception.getStackTrace();
            exception.$dispose();
            
            var stack = [];
            for (var i = 0; i < stackTrace.length; i++) {
                var element = stackTrace[i];
                stack.push('\t' + element.getClassName() + '.' + element.getMethodName() + '(' + element.getFileName() + ':' + element.getLineNumber() + ')');
            }
            
            return '\nStack trace:\n' + stack.join('\n');
        } catch (e) {
            return "\nStack trace not available";
        }
    }
};

// 预加载检查
function checkPrerequisites() {
    logger.info("INIT", "检查运行环境...");
    
    // 检查和创建日志文件
    if (config.fileLogging) {
        try {
            var testFile = new File(config.logFilePath, 'a');
            testFile.close();
            logger.info("INIT", "日志文件就绪: " + config.logFilePath);
        } catch (e) {
            logger.error("INIT", "无法创建日志文件: " + e.message);
            config.fileLogging = false;
        }
    }
    
    logger.info("INIT", "环境检查完成");
}

// 加载模块
function loadModules() {
    logger.info("INIT", "开始加载模块...");
    
    try {
        // 加载加密模块
        logger.debug("INIT", "加载加密监控模块...");
        require('./modules/crypto_monitor.js')(config, logger, utils);
        logger.info("INIT", "加密监控模块加载成功");
        
        // 加载网络模块
        logger.debug("INIT", "加载网络监控模块...");
        require('./modules/network_monitor.js')(config, logger, utils);
        logger.info("INIT", "网络监控模块加载成功");
        
        // 加载反调试模块
        logger.debug("INIT", "加载反调试绕过模块...");
        require('./modules/anti_debug.js')(config, logger, utils);
        logger.info("INIT", "反调试绕过模块加载成功");
        
        // 加载敏感 API 监控模块
        logger.debug("INIT", "加载敏感 API 监控模块...");
        require('./modules/sensitive_api.js')(config, logger, utils);
        logger.info("INIT", "敏感 API 监控模块加载成功");
        
        // 加载自动提取模块
        logger.debug("INIT", "加载自动提取密钥模块...");
        require('./modules/auto_extractor.js')(config, logger, utils);
        logger.info("INIT", "自动提取密钥模块加载成功");
    } catch (e) {
        logger.error("INIT", "模块加载失败: " + e.message + "\n" + e.stack);
    }
}

// 主函数
function main() {
    logger.info("MAIN", "Frida 全功能 Hook 框架初始化...");
    
    checkPrerequisites();
    
    Java.perform(function() {
        logger.info("MAIN", "Java 运行环境准备就绪");
        loadModules();
        logger.info("MAIN", "全部模块加载完成，开始监控");
    });
}

// 启动框架
setTimeout(main, 0); 
